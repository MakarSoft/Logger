# Example 1
# logging_config_ex_1.py 
# https://coderzcolumn.com/tutorials/python/logging-config-simple-guide-to-configure-loggers-from-dictionary-and-config-files-in-python

# Задача - создать простую конфигурацию словаря, которая будет информировать модуль ведения журнала о необходимости направлять все log-сообщения
# с уровнем DEBUG и выше в стандартный поток вывода
#-------------------------------------------------------------------------------

# dictConfig(config_dictionary) — этот метод принимает в качестве входных данных словарь, в котором есть сведения о конфигурации ведения журнала,
# и настраивает модуль ведения журнала на его основе.

# Создаем словарь log_config, в котором есть сведения о конфигурации ведения журнала, такие как
#   - корневой регистратор,
#   - уровень журнала,
#   - обработчики и
#   - средства форматирования.
#
# Словарь установил уровень журнала DEBUG, поэтому будут регистрироваться сообщения журнала на уровне DEBUG и выше.
# Мы включили обработчик StreamHandler для обработки log-сообщений и направляем их на стандартный вывод (консоль).
# Мы также включили средство форматирования в словарь, которое будет форматировать сообщения журнала, включая такие сведения,
# как время, уровень журнала, имя модуля, имя функции, номер строки, сведения о процессе и сведения о потоке.
# Затем мы настроили ведение журнала, передав этот словарь в качестве входных данных для метода dictConfig().
#
# Определина функция addition, который принимает в качестве входных данных два параметра, выполняет сложение с ними и возвращает результаты.
# Она проверяет типы данных входных аргументов и регистрирует предупреждающие сообщения, если они не соответствуют типам данных, указанным
# в качестве входных данных.
# Она также регистрирует сообщения об успешном завершении добавления и регистрирует сообщение об ошибке, если происходит какой-либо сбой.
#
# Словарь для схемы конфигурации 
# Список ключей словаря. Некоторые ключи являются обязательными, а некоторые необязательными.
#
# version (обязательная)  — ключ принимает значение 1, которое является единственным доступным сейчас значением.
#
# root (необязательно)    — ключ представляет корневой регистратор модуля. Когда мы создадим регистратор на уровне модуля, конфигурация,
#                           указанная в качестве значения этого ключа, будет использоваться для его настройки.
#                           Этот ключ принимает словарь, представляющий конфигурацию, имеет список возможных ключей, как показано ниже.
#       level (необязательно)    - ключ уровня принимает строку, указывающую уровень ведения журнала.
#       handlers (необязательно) - ключ handlers принимает список имен обработчиков, которые определены в части словаря обработчиков .
#       filters (необязательно)  - ключ фильтров принимает список имен фильтров, которые определены в части фильтров словаря.
#
# handlers (необязательно) — ключ представляет собой список обработчиков, которые будут использоваться различными регистраторами для обработки сообщений журнала.
#                            Он принимает другой словарь в качестве значения, где каждый ключ этого словаря будет именем обработчика, а значением будет другой словарь,
#                            определяющий этот обработчик.
#                            Ниже приведен список ключей, которые будут присутствовать внутри значения обработчиков, определяющих словарь.
#        class (обязательно)     - ключ принимает строковое значение, указывающее класс обработчика внутри модуля ведения журнала, экземпляр которого должен
#                                  быть создан для создания экземпляра этого обработчика.
#        level (необязательно)   - ключ принимает имя уровня ведения журнала в качестве значения, указывающего уровень ведения журнала обработчика.
#        formatter (необязательно) - ключ принимает имя средства форматирования, которое будет использоваться для форматирования сообщений, обрабатываемых этим обработчиком.
#
# formatters (необязательно) - ключ представляет собой список форматировщиков, которые будут использоваться различными обработчиками для форматирования сообщений.
#                              Этот ключ принимает другой словарь в качестве значения, где каждый ключ этого словаря будет именем средства форматирования,
#                              а значением будет другой словарь, имеющий конфигурацию средства форматирования. Словарь, который будет использоваться для настройки
#                              средства форматирования, может иметь следующие ключи.
#        format (необязательно)  - ключ принимает строку, которая будет использоваться для форматирования сообщений журнала обработчиком, использующим этот модуль форматирования.
#        datefmt (необязательно) - ключ принимает строку, которая будет использоваться для форматирования даты внутри сообщения журнала.
#
# filters (необязательно) - этот ключ представляет собой список фильтров, которые будут использоваться для фильтрации сообщений журнала. Фильтры могут быть прикреплены к разным обработчикам. Значение этого ключа представляет собой словарь, в котором каждый ключ представляет имя фильтра, а каждое значение представляет собой другой словарь, имеющий конфигурацию этого фильтра. Ниже приведен список возможных значений ключей для словаря, которые будут использоваться для настройки отдельного фильтра.
#         () — этот ключ будет иметь имя класса, которое будет иметь определение фильтра. Модуль ведения журнала создаст экземпляр этого класса для создания фильтра.
#         Все остальные пары ключ-значение будут переданы в качестве параметров класса.
#
# loggers (необязательно)  - ключ представляет собой список регистраторов, которые мы можем определить с различными конфигурациями.
#                            Значением этого ключа является другой словарь, каждый ключ которого является именем регистратора, а значением является другой словарь,
#                            имеющий конфигурацию этого регистратора. Список регистраторов можно определить с помощью тех же ключей, которые мы использовали для
#                            определения корневого регистратора, таких как обработчики , уровень , фильтры и т. д.
#
# disable_existing_loggers - ключ принимает логическое значение True или False. Значение True указывает на отключение всех других существующих средств ведения журнала
#                            без полномочий root, а значение False — в противном случае. Если этот ключ не указан, то для него считается значение по умолчанию True .
#
# Приведенное выше объяснение не охватывает все возможные ключи, которые могут быть предоставлены словарю.
# Это список часто используемых возможных ключей.
#
# Наш словарь в этом примере сначала определяет корневой регистратор с одним обработчиком с именем console и уровнем ведения журнала как DEBUG.
# Затем он определяет список обработчиков. У нас есть только один обработчик с именем console, определенный в этом примере, который будет иметь класс StreamHandler.
# Уровень журнала обработчика установлен на DEBUG. Затем мы определили список средств форматирования. В этом примере у нас есть только один модуль форматирования
# с именем std_out, в котором указаны формат журнала и формат даты.

import logging
from logging import config
from typing import Any, Optional

log_config = {
    "version":1,
    "root":{
        "handlers" : ["console"],
        "level": "DEBUG"
    },
    "handlers":{
        "console":{
            "formatter": "std_out",
            "class": "logging.StreamHandler",
            "level": "DEBUG"
        }
    },
    "formatters":{
        "std_out": {
            "format": "%(asctime)s : %(levelname)s : %(module)s : %(funcName)s : %(lineno)d : (Process Details : (%(process)d, %(processName)s), Thread Details : (%(thread)d, %(threadName)s))\nLog : %(message)s",
            "datefmt":"%d-%m-%Y %I:%M:%S"
        }
    },
}

config.dictConfig(log_config)

def addition(a: Any, b: Any) -> Optional[float]:

    logging.debug("Inside Addition Function")
    if isinstance(a, str) and a.isdigit():
        logging.warning("Warning : Parameter A is passed as String. Future versions won't support it.")

    if isinstance(b, str) and b.isdigit():
        logging.warning("Warning : Parameter B is passed as String. Future versions won't support it.")

    try:
        result = float(a) + float(b)
        logging.info("Addition Function Completed Successfully")
        return result
    except Exception as e:
        logging.error("Error Type : {}, Error Message : {}".format(type(e).__name__, e))
        return None


if __name__ == "__main__":
    #logging.info("Current Log Level : {}\n".format(logging.getLevel()))

    result = addition(10,20)
    logging.info("Addition of {} & {} is : {}\n".format(10,20, result))

    result = addition("20",20)
    logging.info("Addition of {} & {} is : {}\n".format("'20'",20, result))

    result = addition("A",20)
    logging.info("Addition of {} & {} is : {}".format("A",20, result))