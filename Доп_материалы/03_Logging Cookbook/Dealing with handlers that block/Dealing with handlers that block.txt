Иногда вам нужно заставить свои обработчики ведения журнала выполнять свою работу, не блокируя поток, из которого вы ведете журнал.
Это распространено в веб-приложениях, хотя, конечно, это происходит и в других сценариях.
Распространенным виновником медленного поведения является SMTPHandler: отправка писем может занять много времени по ряду причин,
не зависящих от разработчика (например, неэффективная почтовая или сетевая инфраструктура).
Но почти любой сетевой обработчик может блокировать: даже операция SocketHandler может выполнять DNS-запрос под капотом,
который слишком медленный (и этот запрос может быть глубоко в коде библиотеки сокетов, ниже уровня Python и вне вашего контроля).

Одним из решений является использование двухкомпонентного подхода.
В первой части подключите QueueHandler только к тем регистраторам, доступ к которым осуществляется из потоков, критичных к производительности.
Они просто пишут в свою очередь, которая может быть увеличена до достаточно большой емкости или инициализирована без верхней границы их размера.
Запись в очередь, как правило, будет принята быстро, хотя вам, вероятно, потребуется перехватить исключение queue.Full в качестве меры предосторожности в вашем коде.
Если вы являетесь разработчиком библиотеки, в коде которой есть критически важные для производительности потоки, обязательно задокументируйте это
(вместе с предложением прикреплять к вашим регистраторам только QueueHandler) для пользы других разработчиков, которые будут использовать ваш код.
Второй частью решения является QueueListener, который был разработан как аналог QueueHandler.
QueueListener очень прост: ему передается очередь и несколько обработчиков, и он запускает внутренний поток, который прослушивает свою очередь на наличие записей LogRecord,
отправленных из QueueHandlers (или любого другого источника записей LogRecord, если на то пошло). Записи журнала удаляются из очереди и передаются обработчикам для обработки.
Преимущество наличия отдельного класса QueueListener заключается в том, что вы можете использовать один и тот же экземпляр для обслуживания нескольких QueueHandler.
Это более бережно к ресурсам, чем, скажем, многопоточные версии существующих классов обработчиков, которые потребляют один поток на обработчик без особой выгоды.

Изменено в версии 3.5: До Python 3.5 QueueListener всегда передавал каждое сообщение, полученное из очереди, каждому обработчику, с которым он был инициализирован.
(Это произошло потому, что предполагалось, что вся фильтрация уровня выполняется на другой стороне, где очередь заполняется.) Начиная с версии 3.5, это поведение можно изменить,
передав аргумент ключевого слова relay_handler_level=True в конструктор слушателя. Когда это сделано, прослушиватель сравнивает уровень каждого сообщения с уровнем обработчика
и передает сообщение обработчику только в том случае, если это уместно.